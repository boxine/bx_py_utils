# Doc-Write: DocStrings -> Markdown files

In short: Doc-Write transfers source code DocStrings into Markdown files.

The philosophy is to add documentation as near to your code as possible.
This is to ensure that the documentation is not out of date.
If you change the code and the documentation is just above it,
then hopefully you update it at the same time ;)

A example looks like this:
```
class FooBar:
    ''' DocWrite: README.md # This is the headline
    This Text will be added to: {output_base_path}/README.md
    '''
    pass
```

This README is generated by Doc-Write.
You can just search for the used prefix to find all code parts that contains DocStrings for this README.
e.g.:
* https://github.com/search?q=repo%3Aboxine%2Fbx_py_utils+%22DocWrite%3A%22&type=code

## Macros

It's possible to define callables in the DocString block by using the `DocWriteMacro:` prefix
and the callable name as dotting path. e.g.:

    DocWriteMacro: foo.bar.baz

Example:

```
def add_context_attributes(macro_context: MacroContext):
    """
    Add MacroContext attributes to the documentation.
    """
    for field in dataclasses.fields(macro_context):
        yield f' * {field.name}: {field.type.__name__}'

```

Macro functions must return a string or an iterable of strings.

The recommendation is not to include the macro functions in the package.
A good place could be next to the tests.
e.g: The bx_py_utils own used doc write macros are stored in:

* `bx_py_utils_tests/doc_write_macros.py`

## Macros - context

All macro functions will get a `MacroContext` dataclass instance as keyword argument with the following attributes:

 * config: DocuwriteConfig
 * path: str
 * headline: str
 * doc_string: str

## Usage

To write your doc files, just call, e.g.:

```
~/your-project-src$ python3 -m bx_py_utils.doc_write
```

You can also compile the documentation via code, e.g.:
```
from bx_py_utils.doc_write.api import generate

generate()
```

Tip: Just include "generate Doc-Write" files" into your unittests.
So you have always up2date documentation files.

Example for a unittest can be found here:

https://github.com/boxine/bx_py_utils/blob/master/bx_py_utils_tests/tests/test_doc_write.py

## pyproject.toml settings

Add a section `[tool.doc_write]` to your `pyproject.toml` to configure Doc-Write.

## pyproject.toml settings [tool.doc_write] example

```
[tool.bx_py_utils.doc_write]
docstring_prefix = 'DocWrite:'
macro_prefix = 'DocWriteMacro:'
output_base_path = './docs/'
search_paths = ['./foo/', './bar/']
delete_obsolete_files = false  # Delete obsolete files in output_base_path
```
Warning: Turn `delete_obsolete_files` only on if output_base_path is exclusively used by Doc-Write.

Defaults are:
 * `docstring_prefix`: `'DocWrite:'`
 * `macro_prefix`: `'DocWriteMacro:'`
 * `delete_obsolete_files`: `False`

### Howto

All Doc-Strings that should be transferred by Doc-Write must start with a special line:
```
{prefix} {file-path} # Headline text
```
The meaning, broken down:
* `{prefix}`: String defined as `docstring_prefix` in your `project.toml` file.
* `{file-path}`: Relative file path to `output_base_path` and must point to a `*.md` file.
* `# Headline text`: The DocString block will be merged under this headline.

Notes:
* `{file-path}` and headline must not be unique!
  The opposite is true: Documentation is assembled from different places!

### Notes

* The created created Markdown file is relative to `output_base_path` (defined in `pyproject.toml`)

* If `delete_obsolete_files` is set to `true` in `pyproject.toml`,
  then all `*.md` files in `output_base_path` that are not in `doc_paths` will be deleted.

* Headlines will be sorted, so they appears ordered by the level.

* All Doc-String without the `{prefix}` will be ignored.

* The `{file-path}` must has the file extension `.md`
Otherwise the DocString block will be ignored.